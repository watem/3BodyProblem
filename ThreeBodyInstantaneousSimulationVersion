  import java.util.Scanner;
  import java.util.Arrays;

// TODO: javadocs


  public class ThreeBody {
  
  //Final variables declaration
  
  public static final double G = 8.64960768*Math.pow(10, -13);//gravitational constant (km^3/kg/h^2)
  public static final double dt = 0.1; //delta t in hours
  public static double tmax ; //number of hours to run
  public static double time = 0; //initial time
  public static final int imax =(int) (tmax/dt); //number of time steps
  public static final boolean graphing = true;
  public static final double au = 1.49597870700*Math.pow(10,8);//initial distance of earth from the sun in km
  public static final double massEarth=5.972*Math.pow(10, 24); //kg
  public static final double massSun=1.989*Math.pow(10, 30);  //kg
  public static double massSat; //kg
  public static final double velocityEarth = 1.08*Math.pow(10, 5);// initial velocity of Earth
  
  public static Scanner kb = new Scanner(System.in);

  public static void main(String[] args) {

	
  System.out.print("Please enter the duration of the simulation: ");
  tmax = kb.nextDouble();
	  
  System.out.print("Please enter the mass of the satellite: ");
  massSat = kb.nextDouble();
	  
  double satX, satY, velInitialX, velInitialY;

  System.out.print("Please enter the initial x position of the satellite: ");
  satX = kb.nextDouble();
  System.out.print("Please enter the initial y position of the satellite: ");
  satY = kb.nextDouble();
  System.out.print("Please enter the initial x velocity of the satellite: ");
  velInitialX = kb.nextDouble();
  System.out.print("Please enter the initial y velocity of the satellite: ");
  velInitialY = kb.nextDouble();

	
  double [][][] object = new double [3][3][2];
  
 // object[a] : a = 0(Earth), a=1(Sun), a=2(Sat)
// object[][b] : b = 0(position), b=1(velocity), b=2(acceleration)
//object[][][c] : c = 0(x position), c=1(y position)
  
  //Earth
  object[0][0][0] = au; 
  object[0][0][1] = 0; 
  
  object[0][1][0] = 0; 
  object[0][1][1] = velocityEarth; 
  
  object[0][2][0] = 0; 
  object[0][2][1] = 0; 
  
  //Sun 
  object[1][0][0] = 0; 
  object[1][0][1] = 0; 
  
  object[1][1][0] = 0; 
  object[1][1][1] = 0; 
  
  object[1][2][0] = 0; 
  object[1][2][1] = 0; 
  
  //Satellite
  object[2][0][0] = satX; 
  object[2][0][1] = satY; 
  
  object[2][0][0] = velInitialX; 
  object[2][0][1] = velInitialY; 
  
  object[2][2][0] = 0; 
  object[2][2][1] = 0; 

  


  System.out.println(Arrays.toString(accelSunAnyObj(massSun,object[0][0],object[1][0])));
  
  double [] maxAccel, minPosSun, minPosEarth;
  maxAccel = object[2][2];
  
  minPosSun = differencePos(object[2][0],object[1][0]);
  minPosEarth = differencePos(object[2][0],object[0][0]);

  while (time<tmax) {
  
  time = time+dt;
//get the instantaneous acceleration of each object
  object[0][2] = accelSunAnyObj(massSun,object[0][0],object[1][0]);
  object[1][2] = accelSunAnyObj(massEarth,object[1][0],object[0][0]);
  object[2][2] = accelSunAnyObj(massSun,object[2][0], object[1][0]);
  object[1][2] = add(object[1][2], accelSunAnyObj(massSat,object[1][0], object[2][0]));
  object[0][2] = add(object[0][2], accelSunAnyObj(massSat,object[0][0],object[2][0]));
  object[2][2] = add(object[2][2], accelSunAnyObj(massEarth, object[2][0],object[0][0]));
  
  //get the instantaneous velocity of each object
  object[0][1] = add((mult(object[0][2])), object[0][1]);
  object[1][1] = add((mult(object[1][2])), object[1][1]);
  object[2][1] = add((mult(object[2][2])), object[2][1]);
  
  //get the instantaneous position of each object
  object[0][0] = add((mult(object[0][1])), object[0][0]);
  object[1][0] = add((mult(object[1][1])), object[1][0]);
  object[2][0] = add((mult(object[2][1])), object[2][0]);
  
  maxAccel = compareAccel(maxAccel,object[2][2]);
  // findMinDis(); //sun
  minPosSun = comparePosition(minPosSun, differencePos(object[2][0],object[1][0]));

// findMinDis(); //earth
  minPosEarth = comparePosition(minPosEarth, differencePos(object[2][0],object[0][0]));

  }

  System.out.println("The maximum acceleration is : " + getMag(maxAccel));
  System.out.println("The minimum distance to Earth is : " + getMag(minPosEarth));
  System.out.println("The minimum distance to Sun is : " + getMag(minPosSun)); 
  

  
  // if (graphing) {
  //   graph();
  // }
}//main()




/**
 * This method takes a double array as an input and multiplies is by the derivative of time
 * 
 * @param double[] array 
 * @return array
 * @authors Matthew Williams,Yulia Kosharych
 * @version 17-05-2018
 */

 public static double [] mult(double [] array) {
 for(int i =0; i<array.length;i++) {
 array[i] = array[i]*dt;	
 }
 return array;
 }


 /**
 * This method takes two double arrays as input and adds them in a new array
 * 
 * @param double[] array
 * @return double add
 * @authors Matthew Williams,Yulia Kosharych
 * @version 17-05-2018
 */


 public static double [] add(double [] array1, double [] array2) {
 double [] add = new double [array1.length];
 for(int i = 0; i < array1.length; i++)
 {
 add[i] = array1[i] + array2[i];
 }
 return add;			
}	
		
/**
* This method takes two double arrays as input representing the position of Sun/Earth and 
* Satellite and subtracts the position of Sun/Earth from that of Satellite
* 
* @param double[] pos1, double [] pos2
* @return result
* @authors Matthew Williams,Yulia Kosharych
* @version 17-05-2018
*/

 public static double [] differencePos(double[] pos1, double [] pos2){
 double [] result = new double[2];
 for(int i =0; i<pos1.length;i++) {				
 result[i] = pos1[i]-pos2[i];
 }
 return result;
 }
		
  /**
 * This method takes a double array as an input and multiplies is by the derivative of time
 * 
 * @param double[] array
 * @return array
 * @authors Matthew Williams,Yulia Kosharych
 * @version 17-05-2018
 */	
 public static double [] getR(double [] objPos1, double [] objPos2) {
 double [] rVector = new double [2];
 rVector[0]= objPos2[0] - objPos1[0];
 rVector[1]= objPos2[1] - objPos1[1];
 return rVector;
 }


  /**
  * This method takes a double array as input and calculates the square root(also called magnitude)
  * of the sum of two array elements to the power of two
  * 
  * @param double[] rVector
  * @return rMagnitude
  * @authors Matthew Williams, Yulia Kosharych
  * @version 17-05-2018
  */
  public static double getMag(double [] rVector) {
  double rMagnitude;
  rMagnitude = Math.sqrt(Math.pow(rVector[0],2) + Math.pow(rVector[1], 2));
  return rMagnitude;
  }

/**
 * This method calculates the unit vector which determines the dirrection of the acceleration vector
 * 
 * @param double [] rVector    this array contains the x and y components of the vector
 * @param double rMagnitude    this is the magnitude of the vector
 * @return array
 * @authors Matthew Williams,Yulia Kosharych
 * @version 17-05-2018
 */	
  public static double [] getUnit(double [] rVector, double rMagnitude ) {	
  double [] unit = new double[2];
  unit[0] = rVector[0]/rMagnitude;
  unit[1] = rVector[1]/rMagnitude;
  return unit;
  }

  /**
  * This method calculates the x and y components of the instantaneous acceleration vector of any object of mass m 
  * under influence of another object 
  * 
  * @param double mPullObj      this is the mass of a object given
  * @param double [] objPos1    this is position vector of the first object
  * @param double [] objPos2    this is position vector of the second object
  * @return accelVector
  * @authors Matthew Williams,Yulia Kosharych
  * @version 17-05-2018
  */	
	  
  public static double [] accelSunAnyObj( double mPullObj,double [] objPos1, double [] objPos2) {

  double rMagnitude;	
  double [] rVector = new double [2];
  double [] unit = new double [2];
  double [] accelVector = new double [2];
  double accelMagnitude;

  rVector = getR(objPos1,objPos2);
  rMagnitude = getMag(rVector);
  unit = getUnit(rVector,rMagnitude);

  accelMagnitude= (G*mPullObj)/ Math.pow(rMagnitude, 2);
  accelVector[0] = accelMagnitude * unit[0];
  accelVector[1] = accelMagnitude * unit[1];
  
  return accelVector;
}


 /**
  * This method compares instantaneous accelerations of an object and returns the greatest acceleration reached
  * 
  * @param double [] accelInitial   
  * @param double [] accelFinal   
  * @return accelFinal
  * @authors Matthew Williams,Yulia Kosharych
  * @version 17-05-2018
  */	

  public static double [] compareAccel(double [] accelInitial, double [] accelFinal) {
  double accelMagIn = getMag(accelInitial);
  double accelMagFin = getMag(accelFinal);
  if (accelMagIn < accelMagFin) {
  return accelFinal;
  }else {
  return accelInitial;
  }	
  }

 /**
  * This method updates instantaneous velocity of an object
  * 
  * @param double [] velInitial   this is the initial velocity vector of an object
  * @param double [] accel        this is the acceleration of the object 
  * @return velInitial            this is the final velocity vector of an object for each dt
  * @authors Matthew Williams,Yulia Kosharych
  * @version 17-05-2018
  */

  public static double [] updateVel(double [] velInitial, double [] accel) {
  velInitial[0] = accel[0] *dt + velInitial[0];
  velInitial[1] = accel[1] *dt + velInitial[1];
  return velInitial;
  }

 /**
  * This method updates instantaneous position of an object
  * 
  * @param double [] posInitial   this is the initial position of an object
  * @param double [] vel          this is the velocity of an object
  * @return posInitial            this is the final position vector of an object for each dt
  * @authors Matthew Williams,Yulia Kosharych
  * @version 17-05-2018
  */

  public static double [] updatePos(double [] posInitial, double [] vel) {
  posInitial[0] = vel[0] * dt + posInitial[0];
  posInitial[1] = vel[1] * dt + posInitial[1];
  return posInitial;		
  }

  public static double[] comparePosition(double[] posInitial, double[] posFinal) {
	
	double magPosIn = getMag(posInitial);
	double magPosFin = getMag(posFinal);
	
	
	if (magPosIn > magPosFin ) {
		
	return posFinal;
		
	}else {
		
	return posInitial;
	}
	
}



  public static double compareVelocity(double[] velInitial, double[] velFinal) {
	
	double magVelIn = getMag(velInitial);
	double magVelFin = getMag(velFinal);
	
	
	if (magVelIn < magVelFin ) {
		
	return magVelFin;
		
	}else {
		
	return magVelIn;
	}
	
}


//TODO: graphing method()
// public static void graph(double[][] satX,double[][] satY,double[][] sunX,double[][] sunY,double[][] earthX,double[][] earthY)




}//end class ThreeBody
