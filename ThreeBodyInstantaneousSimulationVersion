  import java.util.Scanner;
  import java.util.Arrays;

// TODO: javadocs


  public class ThreeBody {
  
  //Final variables declaration
  
  public static final double G = 8.64960768*Math.pow(10, -13);//gravitational constant (km^3/kg/h^2)
  public static final double dt = 0.1; //delta t in hours
  public static double tmax ; //number of hours to run
  public static double time = 0; //initial time
  // public static final double tmax; //number of hours to run {inputs}
  public static final int imax =(int) (tmax/dt); //number of time steps
  // public static final double imax; //number of time steps {inputs}
  public static final boolean graphing = true;
  public static final double au = 1.49597870700*Math.pow(10,8);//initial distance of earth from the sun in km
  // public static final double radEarth=; //km
  // public static final double radSun=; //km

  public static final double massEarth=5.972*Math.pow(10, 24); //kg
  public static final double massSun=1.989*Math.pow(10, 30);  //kg
  public static double massSat; //kg
  public static final double velocityEarth = 1.08*Math.pow(10, 5);// initial velocity of Earth
  public static Scanner kb = new Scanner(System.in);



  public static void main(String[] args) {

	
  System.out.print("Please enter the duration of the simulation: ");
	  tmax = kb.nextDouble();
	  
  System.out.print("Please enter the mass of the satellite: ");
	  massSat = kb.nextDouble();
	  
  double satX, satY, velInitialX, velInitialY;

  // earthX[0][0]=1.495978*Math.pow(10,16);
  // earthX[1][0]=0;
  // earthY[1][0]=108000;
  // earthY[0][0]=0;
  // System.out.println("please enter the mass of the satellite: ");
  // massSat = kb.nextDouble();
  System.out.print("Please enter the initial x position of the satellite: ");
  satX = kb.nextDouble();
  System.out.print("Please enter the initial y position of the satellite: ");
  satY = kb.nextDouble();
  System.out.print("Please enter the initial x velocity of the satellite: ");
  velInitialX = kb.nextDouble();
  System.out.print("Please enter the initial y velocity of the satellite: ");
  velInitialY = kb.nextDouble();

  
  

	
	
  double [][][] object = new double [3][3][2];
  
 // object[a] : a = 0(Earth), a=1(Sun), a=2(Sat)
// object[][b] : b = 0(position), b=1(velocity), b=2(acceleration)
//object[][][c] : c = 0(x position), c=1(y position)
  
  //Earth
  object[0][0][0] = au; 
  object[0][0][1] = 0; 
  
  object[0][1][0] = 0; 
  object[0][1][1] = velocityEarth; 
  
  object[0][2][0] = 0; 
  object[0][2][1] = 0; 
  
  //Sun 
  object[1][0][0] = 0; 
  object[1][0][1] = 0; 
  
  object[1][1][0] = 0; 
  object[1][1][1] = 0; 
  
  object[1][2][0] = 0; 
  object[1][2][1] = 0; 
  
  //Sat
  object[2][0][0] = satX; 
  object[2][0][1] = satY; 
  
  object[2][0][0] = velInitialX; 
  object[2][0][1] = velInitialY; 
  
  object[2][2][0] = 0; 
  object[2][2][1] = 0; 

  


  System.out.println(Arrays.toString(accelSunAnyObj(massSun,object[0][0],object[1][0])));
  
  double [] maxAccel, minPosSun, minPosEarth;
  maxAccel = object[2][2];
  
  minPosSun = differencePos(object[2][0],object[1][0]);
  minPosEarth = differencePos(object[2][0],object[0][0]);

  while (time<tmax) {
  
  time = time+dt;
//get the instantaneous acceleration of each object
  object[0][2] = accelSunAnyObj(massSun,object[0][0],object[1][0]);
  object[1][2] = accelSunAnyObj(massEarth,object[1][0],object[0][0]);
  object[2][2] = accelSunAnyObj(massSun,object[2][0], object[1][0]);
  object[1][2] = add(object[1][2], accelSunAnyObj(massSat,object[1][0], object[2][0]));
  object[0][2] = add(object[0][2], accelSunAnyObj(massSat,object[0][0],object[2][0]));
  object[2][2] = add(object[2][2], accelSunAnyObj(massEarth, object[2][0],object[0][0]));
  
  //get the instantaneous velocity of each object
  object[0][1] = add((mult(object[0][2])), object[0][1]);
  object[1][1] = add((mult(object[1][2])), object[1][1]);
  object[2][1] = add((mult(object[2][2])), object[2][1]);
  
  //get the instantaneous position of each object
  object[0][0] = add((mult(object[0][1])), object[0][0]);
  object[1][0] = add((mult(object[1][1])), object[1][0]);
  object[2][0] = add((mult(object[2][1])), object[2][0]);
  
  maxAccel = compareAccel(maxAccel,object[2][2]);
  // findMinDis(); //sun
  minPosSun = comparePosition(minPosSun, differencePos(object[2][0],object[1][0]));

// findMinDis(); //earth
  minPosEarth = comparePosition(minPosEarth, differencePos(object[2][0],object[0][0]));

  }

  System.out.println("The maximum acceleration is : " + getMag(maxAccel));
  System.out.println("The minimum distance to Earth is : " + getMag(minPosEarth));
  System.out.println("The minimum distance to Sun is : " + getMag(minPosSun)); 
  

  
  // if (graphing) {
  //   graph();
  // }
}//main()




  public static double [] mult(double [] array) {
	
	for(int i =0; i<array.length;i++) {
		
	array[i] = array[i]*dt;	
	}
	
	
	return array;
	
	
}


  public static double [] add(double [] array1, double [] array2) {
	
	
	double [] add = new double [array1.length];
	
	for(int i = 0; i < array1.length; i++)
	{
	add[i] = array1[i] + array2[i];
		
		
	}
	
	return add;
			
}
		
		
	public static double [] differencePos(double[] pos1, double [] pos2){
			
	double [] result = new double[2];
	for(int i =0; i<pos1.length;i++) {
				
	result[i] = pos1[i]-pos2[i];
				
				
			}
	return result;
			
		}
		
  public static double [] getR(double [] objPos1, double [] objPos2) {
	 
	double [] rVector = new double [2];
	
	rVector[0]= objPos2[0] - objPos1[0];
	rVector[1]= objPos2[1] - objPos1[1];
	
	return rVector;
	}


  public static double getMag(double [] rVector) {
	
	double rMagnitude;
	rMagnitude = Math.sqrt(Math.pow(rVector[0],2) + Math.pow(rVector[1], 2));
	return rMagnitude;
}


  public static double [] getUnit(double [] rVector, double rMagnitude ) {
	
  double [] unit = new double[2];

  unit[0] = rVector[0]/rMagnitude;
  unit[1] = rVector[1]/rMagnitude;

  return unit;
  }

  public static double [] accelSunAnyObj( double mPullObj,double [] objPos1, double [] objPos2) {

  double rMagnitude;	
  double [] rVector = new double [2];
  double [] unit = new double [2];
  double [] accelVector = new double [2];
  double accelMagnitude;

  rVector = getR(objPos1,objPos2);
  rMagnitude = getMag(rVector);
  unit = getUnit(rVector,rMagnitude);

  accelMagnitude= (G*mPullObj)/ Math.pow(rMagnitude, 2);
  accelVector[0] = accelMagnitude * unit[0];
  accelVector[1] = accelMagnitude * unit[1];
  
  return accelVector;
}

  public static double [] compareAccel(double [] accelInitial, double [] accelFinal) {
	
	double accelMagIn = getMag(accelInitial);
	double accelMagFin = getMag(accelFinal);
	
	
	
	if (accelMagIn < accelMagFin) {
		
	return accelFinal;
		
	}else {
		
	return accelInitial;
	}
	
	
}

  public static double [] updateVel(double [] velInitial, double [] accel) {
	
	
	velInitial[0] = accel[0] *dt + velInitial[0];
	velInitial[1] = accel[1] *dt + velInitial[1];
	
	
	return velInitial;
}



  public static double [] updatePos(double [] posInitial, double [] vel) {
	
	
	posInitial[0] = vel[0] * dt + posInitial[0];
	posInitial[1] = vel[1] * dt + posInitial[1];
	
	return posInitial;
		
}

  public static double[] comparePosition(double[] posInitial, double[] posFinal) {
	
	double magPosIn = getMag(posInitial);
	double magPosFin = getMag(posFinal);
	
	
	if (magPosIn > magPosFin ) {
		
	return posFinal;
		
	}else {
		
	return posInitial;
	}
	
}



  public static double compareVelocity(double[] velInitial, double[] velFinal) {
	
	double magVelIn = getMag(velInitial);
	double magVelFin = getMag(velFinal);
	
	
	if (magVelIn < magVelFin ) {
		
	return magVelFin;
		
	}else {
		
	return magVelIn;
	}
	
}


//TODO: graphing method()
// public static void graph(double[][] satX,double[][] satY,double[][] sunX,double[][] sunY,double[][] earthX,double[][] earthY)




}//end class ThreeBody
